<h2>Python Queue Exercises for PyQt Applications</h2>

<ol>
  <li>
    <h3>Exercise 1: Buffered Progress Updates for Long-Running Downloads</h3>
    <p><strong>Description:</strong> Create a PyQt application with a GUI button that triggers a background thread to simulate downloading multiple files (e.g., generating fake data chunks over time). The background thread should queue progress updates (like percentage complete for each file), and the main GUI thread should periodically dequeue and display these updates in a text area or progress bar without freezing the interface.</p>
    <p><strong>Hint for Implementation:</strong> Use a <code>Queue</code> instance shared between the threads. In the background thread, use a loop to "download" chunks and call <code>put()</code> with tuples of (file_name, percentage). In the main thread, set up a timer (e.g., every 500ms) to check <code>get_nowait()</code> for updates, process them, and clear any exceptions with <code>task_done()</code>. Ensure the queue has a reasonable maxsize to prevent memory buildup.</p>
    <p><strong>Why Use Python Queue Over Qt Threading Sync Primitives:</strong> In real-world scenarios like network monitoring tools (inspired by Stack Overflow discussions on IMAP mailbox checkers where raw threading caused GUI freezes), Qt signals/slots can flood the event loop with frequent small updates, leading to lag or dropped events. Python's <code>Queue</code> provides built-in buffering and blocking semantics, decoupling the producer's pace from the consumer's processing, which is simpler than manually managing QMutex locks around shared lists or using QSemaphore for signaling availability—avoiding the need to wrap every update in a signal emission.</p>
  </li>

  <li>
    <h3>Exercise 2: Multi-Worker Task Processing for Image Resizing</h3>
    <p><strong>Description:</strong> Build a PyQt file loader GUI where users select multiple images. Spawn a pool of 3-4 background worker threads that dequeue image paths from a shared queue, resize them (using a library like Pillow), and queue the results back to a separate output queue. The GUI thread consumes from the output queue to update a list widget with thumbnails or status messages.</p>
    <p><strong>Hint for Implementation:</strong> Initialize two queues: one for input tasks (populate with file paths after user selection) and one for results (tuples of (original_path, resized_data, status)). Each worker runs in a loop, using <code>get()</code> to fetch tasks (with a sentinel like None to stop), processes the image, and <code>put()</code>s the result. Use <code>join()</code> on threads after queueing a sentinel for each to ensure cleanup.</p>
    <p><strong>Why Use Python Queue Over Qt Threading Sync Primitives:</strong> Drawing from user experiences in parallel URL fetchers (as seen in Python forums where simple threading without queues led to race conditions), managing multiple Qt QThreads with shared data often requires complex QMutex/QReadWriteLock setups to protect lists, which can introduce deadlocks or performance bottlenecks in I/O-heavy tasks. Python's <code>Queue</code> handles multi-producer/multi-consumer coordination transparently with internal locks, making it more straightforward and less error-prone than emitting signals for each sub-task or using Qt's QThreadPool with custom synchronization—especially when the workload varies unpredictably.</p>
  </li>

  <li>
    <h3>Exercise 3: Real-Time Logging from Background Simulations</h3>
    <p><strong>Description:</strong> Develop a PyQt dashboard simulating sensor data (e.g., a loop generating random temperature readings in a background thread). The thread queues log entries (timestamps and values) to a shared queue, while the GUI dequeues them to append to a scrolling text widget, with an option to filter or pause logging via buttons.</p>
    <p><strong>Hint for Implementation:</strong> Employ a single <code>Queue</code> for logs as dicts (e.g., {'time': datetime, 'value': temp}). The background thread runs indefinitely, putting entries every second until a stop signal (perhaps via another queue or flag). In the GUI, use an event loop or timer to <code>get()</code> non-blockingly, update the widget, and handle empty queues gracefully to avoid blocking the UI.</p>
    <p><strong>Why Use Python Queue Over Qt Threading Sync Primitives:</strong> Based on real-user reports from PyQt threading crash logs (e.g., "unknown request in queue" errors on Stack Overflow when mixing Python threads with Qt event queues), direct shared variables with QMutex can cause segfaults if Qt objects are involved. Python's <code>Queue</code> offers exception-safe, thread-agnostic communication that's ideal for high-volume, low-latency logging without the overhead of per-entry signals/slots, which might queue up in Qt's event system and delay other UI interactions—providing cleaner separation than Qt's semaphore-based handshaking.</p>
  </li>

  <li>
    <h3>Exercise 4: Priority Task Queue for User-Interactive Simulations</h3>
    <p><strong>Description:</strong> Implement a PyQt simulation app (e.g., a simple particle system) where user actions (like clicking to add particles) enqueue high-priority tasks, while a background thread enqueues low-priority maintenance tasks (e.g., physics updates). Use a <code>PriorityQueue</code> to ensure user inputs are processed first, with the GUI dequeuing and rendering results smoothly.</p>
    <p><strong>Hint for Implementation:</strong> Opt for <code>PriorityQueue</code> and assign priorities (e.g., 1 for user tasks, 10 for background). Enqueue user tasks directly from button clicks or mouse events into the queue. The renderer (in main thread or a dedicated one) uses a timer to <code>get()</code> highest-priority items first, processes them (e.g., update positions), and redraws the scene.</p>
    <p><strong>Why Use Python Queue Over Qt Threading Sync Primitives:</strong> In experiences shared on Python GUI tutorials (like Real Python's QThread guides, where users noted signal overload in interactive sims), Qt's FIFO signals don't natively support prioritization, forcing custom QTimer-based sorting or multiple signal channels. Python's <code>PriorityQueue</code> integrates seamlessly for variable-priority workloads with automatic heap management, avoiding the boilerplate of Qt's QSemaphore for counting or manual mutex-protected priority lists—making it preferable for responsive, event-driven apps without complicating the Qt signal-slot wiring.</p>
  </li>
</ol>

